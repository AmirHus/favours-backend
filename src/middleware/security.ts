import { Middleware } from 'koa';
import * as jwt from 'jsonwebtoken';
import { AUTH0 } from '../config';
import JwksClient, {
  SigningKey,
  CertSigningKey,
  RsaSigningKey,
} from 'jwks-rsa';
import { getUserById } from '../dbqurries/userDataAccess';
import { IAuth0Token } from '../interfaces/iAuth0Token';

// this will be used to get the public RSA key from auth0
const publicKeySet = JwksClient({
  jwksUri: AUTH0.JWKS_URI,
});

// function to veify the token that is passed
export const tokenVerifier: Middleware = async (ctx, next) => {
  // this checks if the path being called is public and skips the token check
  if (
    publicEndpoints.find((endpoint) => {
      return (
        ctx.request.url.startsWith(endpoint.url) &&
        ctx.request.method === endpoint.method
      );
    })
  ) {
    return next();
  }

  const token = ctx.req.headers.authorization;
  // check if the request has a token
  if (!token) {
    return ctx.throw(401, 'No token');
  }

  const validToken = token.replace('Bearer ', '');
  let decodedToken;
  // decode the token using the public key to ensure it is was actually generated by auth0
  try {
    decodedToken = await (() => {
      return new Promise((resolve, reject) => {
        jwt.verify(
          validToken,
          getKey,
          undefined,
          (error: jwt.VerifyErrors, decoded: object | string) => {
            if (!error) {
              return resolve(decoded);
            }
            reject(error);
          }
        );
      });
    })();
  } catch (error) {
    console.error(error);
    // check to see if the token is expired
    if (error instanceof Error && error.name === 'TokenExpiredError') {
      return ctx.throw(401, 'Token expired');
    }
    return ctx.throw(401, 'Invalid token');
  }
  // load the auth0 user details and database details in the state
  // this will be used to determine which user made the api call
  const auth0User = decodedToken as IAuth0Token;
  const user = await getUserById(auth0User.sub);
  // if the user doesn't exist in the database it means it wasn't created through this api
  if (!user) ctx.throw(401, 'user does not exist');
  ctx.state = { auth0User, user };
  return next();
};

// this gets the public key set to be used by jwt to verify tokens
function getKey(header: jwt.JwtHeader, callback: jwt.SigningKeyCallback): void {
  if (!header.kid) {
    return;
  }

  publicKeySet.getSigningKey(
    header.kid,
    (err: Error | null, key: SigningKey) => {
      if (err) {
        console.log(err);
        callback(err);
        return;
      }
      const signingKey =
        (key as CertSigningKey).publicKey ||
        (key as RsaSigningKey).rsaPublicKey;
      callback(null, signingKey);
      return;
    }
  );
}

// list of public paths that don't need a token to access
const publicEndpoints = [
  { url: '/auth/token', method: 'POST' },
  { url: '/user', method: 'POST' },
  { url: '/publicRequest/available', method: 'GET' },
  { url: '/publicRequest', method: 'GET' },
  { url: '/publicRequest/leaderboard', method: 'GET' },
];
